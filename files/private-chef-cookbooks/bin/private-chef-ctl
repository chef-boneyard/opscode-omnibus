#!/opt/opscode/embedded/bin/ruby
#
# Author:: Adam Jacob (<adam@opscode.com>)
# Copyright:: Copyright (c) 2011 Opscode, Inc.
# License:: Apache License, Version 2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

require 'json'
require 'fileutils'

File::umask(022)

SV_COMMAND_NAMES = %w[status up down once pause cont hup alarm interrupt quit
                      1 2 term kill start stop restart shutdown force-stop
                      force-reload force-restart force-shutdown check]

def get_pgrp_from_pid(pid)
  ps=`which ps`.chomp
  `#{ps} -p #{pid} -o pgrp=`.chomp
end

def get_pids_from_pgrp(pgrp)
  pgrep=`which pgrep`.chomp
  `#{pgrep} -g #{pgrp}`.split(/\n/).join(" ")
end

def sigkill_pgrp(pgrp)
  pkill=`which pkill`.chomp
  run_command("#{pkill} -9 -g #{pgrp}")
end

def run_command(command)
	system(command)
	$?
end

def service_list
  get_all_services.each do |service_name|
    print "#{service_name}"
    print "*" if service_enabled?(service_name)
    print "\n"
  end
  exit 0
end

def cleanup_procs_and_nuke(filestr)
  begin
    run_sv_command("stop") 
  rescue SystemExit
  end

  FileUtils.rm_f("/etc/init/opscode-runsvdir.conf") if File.exists?("/etc/init/opscode-runsvdir.conf")
  run_command("egrep -v '/opt/opscode/embedded/bin/runsvdir-start' /etc/inittab > /etc/inittab.new && mv /etc/inittab.new /etc/inittab") if File.exists?("/etc/inittab")
  run_command("kill -1 1")

  backup_dir = Time.now.strftime("/root/opc-cleanse-%FT%R")
  FileUtils.mkdir_p("/root") unless File.exists?("/root")
  FileUtils.rm_rf(backup_dir)
  FileUtils.cp_r("/etc/opscode", backup_dir) if File.exists?("/etc/opscode")
  run_command("rm -rf #{filestr}")

  graceful_kill

  run_command("pkill -HUP -u opscode,opscode-pgsql,opscode-nagios,opscode-nagios-cmd")
  run_command("pkill -HUP -f 'runsvdir -P /opt/opscode/service'")
    sleep 3
  run_command("pkill -TERM -u opscode,opscode-pgsql,opscode-nagios,opscode-nagios-cmd")
  run_command("pkill -TERM -f 'runsvdir -P /opt/opscode/service'")
    sleep 3
  run_command("pkill -KILL -u opscode,opscode-pgsql,opscode-nagios,opscode-nagios-cmd")
  run_command("pkill -KILL -f 'runsvdir -P /opt/opscode/service'")

  puts "Your config files have been backed up to #{backup_dir}."
  exit 0
end

def pre_uninstall
  cleanup_procs_and_nuke("/tmp/opt")
end

def cleanse
  puts "This will delete *all* configuration, log, and variable data associated with this Private Chef Instance.\n\n*** You have 60 seconds to hit CTRL-C ***\n\n"
  unless ARGV[1] == "yes"
    sleep 60
  end
  cleanup_procs_and_nuke("/opt/opscode/service/* /tmp/opt /var/opt/opscode /etc/opscode /var/log/opscode")
end

def get_all_services_files
  Dir["/opt/opscode/sv/*"]
end

def get_all_services
  get_all_services_files.map { |f| File.basename(f) } 
end

def service_enabled?(service_name)
  File.symlink?("/opt/opscode/service/#{service_name}")
end

def run_sv_command(sv_cmd, service=nil)
  exit_status = 0
  get_all_services.each do |service_name|
    next if !service.nil? && service_name != service
    if service_enabled?(service_name)
      status = run_command("/opt/opscode/init/#{service_name} #{sv_cmd}")
      exit_status = status.exitstatus if exit_status == 0 && !status.success?
    else
      puts "#{service_name} disabled" if sv_cmd == "status"
    end
  end
  exit exit_status
end

def show_config
  status = run_command("/opt/opscode/bin/chef-solo -c /opt/opscode/embedded/cookbooks/solo.rb -j /opt/opscode/embedded/cookbooks/show-config.json -l fatal")
	exit 0
end

def reconfigure
  if File.exists?("/etc/opscode/chef-server.json")
    status = run_command("/opt/opscode/bin/chef-solo -c /opt/opscode/embedded/cookbooks/solo.rb -j /etc/opscode/chef-server.json -l info")
  else
    status = run_command("/opt/opscode/bin/chef-solo -c /opt/opscode/embedded/cookbooks/solo.rb -j /opt/opscode/embedded/cookbooks/dna.json -l info")
  end
  if status.success?
    puts "Chef Server Reconfigured!"
    exit 0
  else
    exit 1
  end
end

# start (start all services) is special cased to deal with backend complexity
def start
  load_json
  if @running_config['private_chef']['keepalived']['enable']
    run_sv_command("start", "keepalived")
    run_sv_command("start", "nrpe")
  else
    run_sv_command("start")
  end
end

def tail(service=nil)
  if service
    system("find /var/log/opscode/#{service} -type f | grep -E -v '(lock|@|sasl|idx|siz|nagios|nrpe)' | xargs tail --follow=name --retry")
  else
    system("find /var/log/opscode -type f | grep -E -v '(lock|@|sasl|idx|siz|nagios|nrpe)' | xargs tail --follow=name --retry")
  end
end

def load_json
  json = File.read("/etc/opscode/chef-server-running.json")
  @running_config = JSON.parse(json)
end

#
# ha_status
#  - check keepalived is actually enabled in the config
#  - check drbd is actually enabled in the config
#  - check that someone created the underlying block device drbd will use
#  - check that the drbd device itself exists (i.e. kernel module configured+loaded)
#  - check that the current state matches requested state of master or backup
#  - check that the VRRP IP address state is correct based on our state
#  - check that the DRBD state is correct based on our state
#  - check that the DRBD drive is correctly (un)mounted based on our state
#  - check that the DRBD primary+secondary replication IP are both pingable
#  - check that the runit service status is correct based on our state
#

def ha_status
  load_json

  error_exit = 0

  if @running_config['private_chef']['keepalived']['enable']
    puts "[OK] keepalived HA services enabled."
  else
    puts "[ERROR] keepalived HA services not enabled, please configure keepalived according to documentation."
    exit 1 
  end

  if @running_config['private_chef']['drbd']['enable']
    puts "[OK] DRBD disk replication enabled."
  else
    puts "[ERROR] DRBD disk recplication services not enabled, please configure DRBD according to documentation."
    exit 1 
  end

  drbd_disk = @running_config['private_chef']['drbd']['disk']
  if File.exists?(drbd_disk)
    puts "[OK] DRBD partition #{drbd_disk} found."
  else
    puts "[ERROR] DRBD partition #{drbd_disk} not found, please FIXME."
    exit 1
  end

  drbd_device = @running_config['private_chef']['drbd']['device']
  if File.exists?(drbd_device)
    puts "[OK] DRBD device #{drbd_device} found."
  else
    puts "[ERROR] DRBD device #{drbd_device} not found, please FIXME."
    exit 1
  end

  requested_cluster_status = File.read("/var/opt/opscode/keepalived/requested_cluster_status").chomp
  current_cluster_status = File.read("/var/opt/opscode/keepalived/current_cluster_status").chomp

  if requested_cluster_status != current_cluster_status
    puts "[WARN] inconsistent cluster status, requested: #{requested_cluster_status}, current: #{current_cluster_status}, failover running?"
    error_exit = 2
  else
    puts "[OK] cluster status = #{current_cluster_status}"
  end
 
  vrrp_instance_ipaddress = @running_config['private_chef']['keepalived']['vrrp_instance_ipaddress']
  vrrp_instance_ipaddress_dev = @running_config['private_chef']['keepalived']['vrrp_instance_ipaddress_dev']
  has_vrrp_addr = `ip a show dev #{vrrp_instance_ipaddress_dev}` =~ /#{vrrp_instance_ipaddress}/

  if has_vrrp_addr 
    if current_cluster_status == "master"
      puts "[OK] found VIP IP address and I am master"
    else
      puts "[ERROR] found VRRP address and I am not master"
      error_exit = 3
    end
  else
    if current_cluster_status == "master"
      puts "[ERROR] did not find VIP IP address and I am master"
      error_exit = 3
    else
      puts "[OK] did not find VIP IP address and I am not master"
    end
  end

  vrrp_instance_interface = @running_config['private_chef']['keepalived']['vrrp_instance_interface']
  has_vrrp_instance_interface = system "ip a show dev #{vrrp_instance_interface} >/dev/null 2>&1"

  if has_vrrp_instance_interface
    puts "[OK] found VRRP communications interface #{vrrp_instance_interface}"
  else
    puts "[ERROR] VRRP communications interface #{vrrp_instance_interface} not found, is heartbeat_device set correctly in private-chef.rb?"
    error_exit = 8
  end

  drbd_status = `cat /proc/drbd | egrep cs:`.chomp
  if current_cluster_status == "master"
    if drbd_status =~ /cs:Connected ro:Primary\/Secondary ds:UpToDate\/UpToDate/
      puts "[OK] my DRBD status is Connected/Primary/UpToDate and I am master"
    else
      puts "[ERROR] my DRBD status is: #{drbd_status}"
      error_exit = 4
    end
  else
    if drbd_status =~ /cs:Connected ro:Secondary\/Primary ds:UpToDate\/UpToDate/
      puts "[OK] my DRBD status is Connected/Secondary/UpToDate and I am master"
    else
      puts "[ERROR] my DRBD status is #{drbd_status}"
      error_exit = 4
    end
  end

  drbd_mountpoint = @running_config['private_chef']['drbd']['data_dir']
  mps = []
  File.read("/proc/mounts").each_line { |l| mps << l.split(/\s+/)[1] }
  if current_cluster_status == "master"
    if mps.include?(drbd_mountpoint)
      puts "[OK] my DRBD partition is mounted and I am master"
    else
      puts "[ERROR] my DRBD partition is not mounted and I am master"
      error_exit = 5
    end
  else
    if mps.include?(drbd_mountpoint)
      puts "[ERROR] my DRBD partition is mounted and I am not master"
      error_exit = 5
    else
      puts "[OK] my DRBD partition is not mounted and I am master"
    end
  end

  drbd_primary_ip = @running_config['private_chef']['drbd']['primary']['ip']
  if system("ping -c 1 -W 1 #{drbd_primary_ip} >/dev/null 2>&1")
    puts "[OK] DRBD primary IP address pings"
  else
    puts "[ERROR] DRBD primary IP address does not ping"
    error_exit = 6
  end

  drbd_secondary_ip = @running_config['private_chef']['drbd']['secondary']['ip']
  if system("ping -c 1 -W 1 #{drbd_secondary_ip} >/dev/null 2>&1")
    puts "[OK] DRBD secondary IP address pings"
  else
    puts "[ERROR] DRBD secondary IP address does not ping"
    error_exit = 6
  end

  ha_services = @running_config['private_chef'].select {|k,v| v.is_a?(Hash) && v['ha'] }.map {|k,v| k}
  ha_services += %w{php-fpm fcgiwrap opscode-expander-reindexer}

  get_all_services.sort.each do |service_name|
    if service_enabled?(service_name)
      status = run_command("/opt/opscode/init/#{service_name} status >/dev/null 2>&1")
      if ha_services.include?(service_name)
        if current_cluster_status == "master"
          if status.success?
            puts "[OK] #{service_name} is running correctly, and I am master."
          else
            puts "[ERROR] #{service_name} is not running correctly, and I am master. "
            error_exit = 7
          end
        else
          if status.success?
            puts "[ERROR] #{service_name} is running, and I am not master."
            error_exit = 7
          else
            puts "[OK] #{service_name} is not running, and I am not master."
          end
        end
      else
        if status.success?
          puts "[OK] #{service_name} is running."
        else
          puts "[ERROR] #{service_name} is not running."
          error_exit = 7
        end
      end
    end
  end

  if error_exit != 0
    puts "\n[ERROR] ERRORS WERE DETECTED.\n\n"
  else
    puts "\n[OK] all checks passed.\n\n"
  end

  exit error_exit
end

def is_integer?(string)
  return true if Integer(string) rescue false
end

def graceful_kill(service=nil)
  exit_status = 0
  get_all_services.each do |service_name|
    next if !service.nil? && service_name != service
    if service_enabled?(service_name)
      pidfile="/opt/opscode/sv/#{service_name}/supervise/pid"
      pid=File.read(pidfile).chomp if File.exists?(pidfile)
      if pid.nil? || !is_integer?(pid)
        puts "could not find #{service_name} runit pidfile (service already stopped?), cannot attempt SIGKILL..."
        status = run_command("/opt/opscode/init/#{service_name} stop")
        exit_status = status.exitstatus if exit_status == 0 && !status.success?
        next
      end
      pgrp=get_pgrp_from_pid(pid)
      if pgrp.nil? || !is_integer?(pgrp)
        puts "could not find pgrp of pid #{pid} (not running?), cannot attempt SIGKILL..."
        status = run_command("/opt/opscode/init/#{service_name} stop")
        exit_status = status.exitstatus if exit_status == 0 && !status.success?
        next
      end
      run_command("/opt/opscode/init/#{service_name} stop")
      pids=get_pids_from_pgrp(pgrp)
      if !pids.empty?
        puts "found stuck pids still running in process group: #{pids}, sending SIGKILL" unless pids.empty?
        sigkill_pgrp(pgrp)
      end
    else
      puts "#{service_name} disabled, not stopping"
      exit_status = 1
    end
  end 
  exit exit_status
end

def help
  puts "#{$0}: command (subcommand)"
  puts <<-EOH
  All commands except "show-config", "reconfigure", "service-list",
  "cleanse", "master-recover" and "backup-recover" can be prepended 
  with a service name, and will only apply to that service. 

  # Would show the status of all services
  $ #{$0} status

  # Would show only the status of opscode-chef 
  $ #{$0} opscode-chef status

show-config
    Show the configuration that would be generated by reconfigure. 
reconfigure
    Reconfigure private chef.
upgrade
    Upgrade your private chef installation.
cleanse
    Delete *all* private chef data, and start from scratch.
pre-uninstall
    Prep the system for an upgrade.
master-recover
    Set this server to HA master state, ignoring VRRP
backup-recover
    Set this server to HA backup state, ignoring VRRP
service-list
    List all the services (enabled services appear with a *.)
status
    Show the status of all the services.
ha-status
    Show the status of high availability services.
tail
    Watch the service logs of all enabled services.
start
    Start services if they are down, and restart them if they stop.
stop
    Stop the services, and do not restart them.
restart
    Stop the services if they are running, then start them again.
once
    Start the services if they are down. Do not restart them if they stop.
hup
    Send the services a HUP.
term
    Send the services a TERM.
int
    Send the services an INT.
kill 
    Send the services a KILL.
graceful-kill
    Attempt a graceful stop, then SIGKILL the entire process group.
test
    Run the API test suite against localhost.
EOH
  exit 1
end

case ARGV[1]
when *SV_COMMAND_NAMES
  run_sv_command(ARGV[1], ARGV[0])
when "tail"
  tail(ARGV[0])
when "graceful-kill"
  graceful_kill(ARGV[0])
else
  case ARGV[0]
  when "upgrade"
    # Currently just does reconfigure, but here in case we make it more complicated 
    # during an upgrade cycle.
    reconfigure
  when "ha-status"
    ha_status
  when "master-recover"
  	exec "/var/opt/opscode/keepalived/bin/cluster.sh master"
  when "backup-recover"
  	exec "/var/opt/opscode/keepalived/bin/cluster.sh backup"
  when "service-list"
    service_list
  when "cleanse"
    cleanse
  when "pre-uninstall"
    pre_uninstall
  when "show-config"
  	show_config
  when "reconfigure"
    reconfigure
  when "tail"
    tail
  when "start"
    start
  when "graceful-kill"
    graceful_kill
  when "test"
    ENV["PATH"] = "/opt/opscode/embedded/bin:#{ENV['PATH']}"
    pedant_args = ARGV[1..-1]
    Dir.chdir("/opt/opscode/embedded/service/opscode-pedant")
    exec("/opt/opscode/embedded/bin/bundle exec ./bin/opscode-pedant #{pedant_args.join(' ')}")
  when *SV_COMMAND_NAMES
    if ARGV[1]
      puts "i don't know that command, did you mean: private-chef-ctl #{ARGV[1]} #{ARGV[0]}?"
      exit 1
    else
      run_sv_command(ARGV[0])
    end
  when nil
    help
  else
    help
  end
end
