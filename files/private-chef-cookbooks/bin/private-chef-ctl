#!/opt/opscode/embedded/bin/ruby
#
# Author:: Adam Jacob (<adam@opscode.com>)
# Copyright:: Copyright (c) 2011 Opscode, Inc.
# License:: Apache License, Version 2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


def get_pgrp_from_pid(pid)
  ps=`which ps`.chomp
  `#{ps} -p #{pid} -o pgrp=`.chomp
end

def get_pids_from_pgrp(pgrp)
  pgrep=`which pgrep`.chomp
  `#{pgrep} -g #{pgrp}`.split(/\n/).join(" ")
end

def sigkill_pgrp(pgrp)
  pkill=`which pkill`.chomp
  run_command("#{pkill} -9 -g #{pgrp}")
end

def run_command(command)
	system(command)
	$?
end

def service_list
  get_all_services.each do |service_name|
    print "#{service_name}"
    print "*" if service_enabled?(service_name)
    print "\n"
  end
  exit 0
end

def cleanse
  puts "This will delete *all* configuration, log, and variable data associated with this Private Chef Instance.\n\n*** You have 60 seconds to hit CTRL-C ***\n\n"
  unless ARGV[1] == "yes"
    sleep 60
  end
  begin
    run_sv_command("stop") 
  rescue SystemExit
  end
  status = run_command("rm -rfv /opt/opscode/service/* /var/opt/opscode /etc/opscode /var/log/opscode")
  exit_status = status.exitstatus if exit_status == 0 && !status.success?
  puts "You probably want to run #{$0} reconfigure now."
  exit 0
end

def get_all_services_files
  Dir["/opt/opscode/sv/*"]
end

def get_all_services
  get_all_services_files.map { |f| File.basename(f) } 
end

def service_enabled?(service_name)
  File.symlink?("/opt/opscode/service/#{service_name}")
end

def run_sv_command(sv_cmd, service=nil)
  exit_status = 0
  get_all_services.each do |service_name|
    next if !service.nil? && service_name != service
    if service_enabled?(service_name)
      status = run_command("/opt/opscode/init/#{service_name} #{sv_cmd}")
      exit_status = status.exitstatus if exit_status == 0 && !status.success?
    else
      puts "#{service_name} disabled" if sv_cmd == "status"
    end
  end
  exit exit_status
end

def show_config
  status = run_command("/opt/opscode/bin/chef-solo -c /opt/opscode/embedded/cookbooks/solo.rb -j /opt/opscode/embedded/cookbooks/show-config.json -l fatal")
	exit 0
end

def reconfigure
  if File.exists?("/etc/opscode/chef-server.json")
    status = run_command("/opt/opscode/bin/chef-solo -c /opt/opscode/embedded/cookbooks/solo.rb -j /etc/opscode/chef-server.json -l info")
  else
    status = run_command("/opt/opscode/bin/chef-solo -c /opt/opscode/embedded/cookbooks/solo.rb -j /opt/opscode/embedded/cookbooks/dna.json -l info")
  end
  if status.success?
    puts "Chef Server Reconfigured!"
    exit 0
  else
    exit 1
  end
end

def tail(service=nil)
  if service
    system("find /var/log/opscode/#{service} -type f | grep -E -v '(lock|@|sasl|idx|siz|nagios|nrpe)' | xargs tail --follow=name --retry")
  else
    system("find /var/log/opscode -type f | grep -E -v '(lock|@|sasl|idx|siz|nagios|nrpe)' | xargs tail --follow=name --retry")
  end
end

def is_integer?(string)
  return true if Integer(string) rescue false
end

def graceful_kill(service=nil)
  exit_status = 0
  get_all_services.each do |service_name|
    next if !service.nil? && service_name != service
    if service_enabled?(service_name)
      pidfile="/opt/opscode/sv/#{service_name}/supervise/pid"
      pid=File.read(pidfile).chomp if File.exists?(pidfile)
      if pid.nil? || !is_integer?(pid)
        puts "could not find #{service_name} runit pidfile (service already stopped?), cannot attempt SIGKILL..."
        status = run_command("/opt/opscode/init/#{service_name} stop")
        exit_status = status.exitstatus if exit_status == 0 && !status.success?
        next
      end
      pgrp=get_pgrp_from_pid(pid)
      if pgrp.nil? || !is_integer?(pgrp)
        puts "could not find pgrp of pid #{pid} (not running?), cannot attempt SIGKILL..."
        status = run_command("/opt/opscode/init/#{service_name} stop")
        exit_status = status.exitstatus if exit_status == 0 && !status.success?
        next
      end
      run_command("/opt/opscode/init/#{service_name} stop")
      pids=get_pids_from_pgrp(pgrp)
      if !pids.empty?
        puts "found stuck pids still running in process group: #{pids}, sending SIGKILL" unless pids.empty?
        sigkill_pgrp(pgrp)
      end
    else
      puts "#{service_name} disabled, not stopping"
      exit_status = 1
    end
  end 
  exit exit_status
end

def sv_command_list
  ["status","up","down","once","pause","cont","hup","alarm","interrupt","quit","1","2","term","kill","start","stop","restart","shutdown","force-stop","force-reload","force-restart","force-shutdown","check"]
end

def help
  puts "#{$0}: command (subcommand)"
  puts <<-EOH
  All commands except "show-config", "reconfigure", "service-list",
  "cleanse", "master-recover" and "backup-recover" can be prepended 
  with a service name, and will only apply to that service. 

  # Would show the status of all services
  $ #{$0} status

  # Would show only the status of opscode-chef 
  $ #{$0} opscode-chef status

show-config
    Show the configuration that would be generated by reconfigure. 
reconfigure
    Reconfigure private chef.
cleanse
    Delete *all* private chef data, and start from scratch.
master-recover
    Set this server to HA master state, ignoring VRRP
backup-recover
    Set this server to HA backup state, ignoring VRRP
service-list
    List all the services (enabled services appear with a *.)
status
    Show the status of all the services.
tail
    Watch the service logs of all enabled services.
start
    Start services if they are down, and restart them if they stop.
stop
    Stop the services, and do not restart them.
restart
    Stop the services if they are running, then start them again.
once
    Start the services if they are down. Do not restart them if they stop.
hup
    Send the services a HUP.
term
    Send the services a TERM.
int
    Send the services an INT.
kill 
    Send the services a KILL.
graceful-kill
    Attempt a graceful stop, then SIGKILL the entire process group.
EOH
  exit 1
end

case ARGV[0]
when "master-recover"
	exec "/var/opt/opscode/keepalived/bin/cluster.sh master"
when "backup-recover"
	exec "/var/opt/opscode/keepalived/bin/cluster.sh backup"
when "service-list"
  service_list
when "cleanse"
  cleanse
when "show-config"
	show_config
when "reconfigure"
  reconfigure
when "tail"
  tail
when "graceful-kill"
  graceful_kill
else
  if sv_command_list.include?(ARGV[0])
    run_sv_command(ARGV[0])
  elsif get_all_services.include?(ARGV[0])
    if sv_command_list.include?(ARGV[1])
      run_sv_command(ARGV[1], ARGV[0])
    else
      case ARGV[1]
      when "tail"
        tail(ARGV[0])
      when "graceful-kill"
        graceful_kill(ARGV[0])
      end
    end
  else
    help
  end
end

