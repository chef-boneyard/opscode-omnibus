module("routes", package.seeall)

-- For lpeg syntax, reference www.inf.puc-rio.br/~roberto/lpeg/
local lpeg = require "lpeg"
local match = lpeg.match
local P  = lpeg.P
local B  = lpeg.B
local S  = lpeg.S
local R  = lpeg.R
local C  = lpeg.C
local Ct = lpeg.Ct
local Cg = lpeg.Cg
local Cc = lpeg.Cc

-- create a capture that maps the value of 'name' to capture group "route_id"
local function Crt(name)
  return Cg(Cc(name), "route_id")
end

-- create a capture that maps the captured value of 'exp' to capture group 'endpoint'
local function Cendpoint(exp)
  return Cg(exp, "endpoint")
end


-- Basic identifiers
local p_eol = P(-1)
local p_lower = R"az"
local p_upper = R"AZ"
local p_numeric = R"09"
local p_special = S"_-"
local p_sep = P"/"
local p_dot = P"."

-- Route Components
local p_org = P"organizations"
local p_org_base = P"/organizations"
local p_verify_password = P"verify_password"
local p_auth_user = P"authenticate_user"
local p_acl = P"/_acl"
local p_search = P"search"
local p_nodes = P"nodes"
local p_cookbooks = P"cookbooks"
local p_data = P"data"
local p_roles = P"roles"
local p_sandboxes = P"sandboxes"
local p_environments = P"environments"
local p_users = P"users"
local p_groups = P"groups"
local p_containers = P"containers"
local p_association_requests = P"association_requests"
local p_clients = P"clients"
local p_runs = P"runs"
local p_principals = P"principals"

-- Composite patterns
local p_maybe_sep = p_sep^-1
local p_trailing_sep = p_maybe_sep * p_eol
local p_org_identifier_char = p_lower + p_numeric + p_special
local p_org_identifier = p_org_identifier_char^1
local p_until_next_separator = (P(1) - p_sep)^1

-- Because we implement different identifiers differently (users & orgs have one set of rules,
-- other objects have different rules) accept anything up to but not including the separator
-- as an identifier sufficient to pass along to the upstream.
local p_identifier = p_until_next_separator

local p_org_prefix = p_org_base * p_sep
local p_named_org = p_org_prefix * Cg(p_org_identifier, "org_name")
local p_named_org_prefix = p_named_org * p_sep
local p_all_until_acl = (P(1) - p_acl)^1
-- Not techncially for routing, this will be used to capture chef version from inbound headers
-- leaving it here to keep all of our grammar in one location.
local p_chef_version = Cg(p_numeric^1, "major") * p_dot * Cg(p_numeric^1, "minor") * p_dot


-- ROUTE CAPTURES
-- These captures will map the constant name to the capture group "route_id".
-- If you're adding a new route, the first step is to define the capture that returns
-- the route name below:

local c_acct = Crt("acct")
local c_erchef = Crt("erchef")
local c_acct_erchef = Crt("acct_erchef")

-- The "valid identifier" capture is used for any object name such
-- as node name, user name, etc.
local c_identifier = Cg(p_identifier, "object_name")

local c_maybe_identifier = (p_sep * c_identifier)^-1

local p_erchef_endpoint = p_cookbooks + p_data + p_roles + p_sandboxes +
                          p_environments + p_clients + p_nodes + p_principals

-- endpoints that map directly to erchef
-- If an object identifier is present - as identified with /IDENTIFIER - then
-- capture it. Otherwise -- require end-of-line (in other words, avoid the case
-- of "/nodesSOMEDATA" resolving to 'nodes' endpoint.
local p_erchef_direct = (Cendpoint(p_erchef_endpoint) * ((p_sep * c_identifier) + (p_maybe_sep * p_eol))) +
                        Cendpoint(p_search)

-- Everything that gets sent to erchef
local p_erchef = p_named_org_prefix * p_erchef_direct

-- /users endpoints for account
local p_acct_users = (p_sep * Cendpoint(p_users) * (p_sep * c_identifier)^-1 * p_trailing_sep) +
                     (p_sep * p_users * p_sep * c_identifier) *
                          -- below rule for backwards compatibility with original:
                          -- /users/BLAH/{0,1}/association_requests
                          -- which permits: /users/BLAH//association_requests
                          ( (p_sep * p_maybe_sep * Cendpoint(p_association_requests) * (p_sep + p_eol)) +
                          (p_sep * Cendpoint(p_org) * p_trailing_sep) )

-- account endpoints
-- note that the acl endpoint is a special case because it supercedes all others
-- including routes that would otherwise go to erchef.
local p_acl_endpoint = p_named_org_prefix * p_all_until_acl * Cendpoint(p_acl) * (p_sep + p_eol)
local p_acct_direct = Cendpoint(p_users + p_association_requests) * (p_sep + p_eol)
local p_acct = (p_sep * Cendpoint(p_verify_password + p_auth_user) * p_eol) +
               (p_named_org_prefix * p_acct_direct) +
               (p_sep * Cendpoint(p_org) * (p_sep * Cg(p_org_identifier, "org_name"))^-1 * p_trailing_sep) +
               p_acct_users

--
-- darklaunch endpoints - these need to capture the endpoint name itself for darklaunch resolution
--
-- NOTE: this is held here as a placeholder.  As we begin phase 3 migrations,
-- we will need to enable it by moving migrated endpoints into it.
-- Migration Phase 3: uncomment and add one or more endpoints by name as
-- they are migrated to erchef, for example replace p_clients with p_users
local c_dl_acct_erchef_endpoint = Cendpoint(p_containers) + Cendpoint(p_groups)
local p_dl_acct_erchef = p_named_org_prefix * c_dl_acct_erchef_endpoint * c_maybe_identifier

-- As components complete migration from acct, we will  move them to this
-- expression. Used further down, it will ensure that requests routed to 'account internal'
-- will still end up in erchef.  Once webui1 is retired, these rules are no longer
-- necessary
local p_migrated_erchef_from_acct = p_clients

local uri_resolvers = {
  -- Retain ordering to ensure proper eval:
  -- p_acl_endpont must come firs tbecause a trailing _acl takes precedence
  -- over any other identifiers which may be in the url.
  api = (p_acl_endpoint * c_acct) +
        (p_erchef * c_erchef) +
        -- (p_dl_acct_erchef * c_acct) +
        -- Enable below and remove above if we need to have redis configuration
        -- flags determine routing between acct/erchef.
        -- Make the same change to internal_acct,, below.
        (p_dl_acct_erchef * c_acct_erchef) +

        (p_acct * c_acct),

  -- This one is easy - everything passes through, though we'll still need to capture components
  -- (org name, object name, endpoint name) where we can, so that post-route hooks can be applied.
  internal_acct = -- (p_dl_acct_erchef * c_acct) +
                  (p_dl_acct_erchef * c_acct_erchef) +
                  (p_acl_endpoint * c_acct) +
                  -- As described above, w eneed to keep routes of migrated components in place so that
                  -- webui1 requests sent directly to internal acct land in the right place.
                  ((p_named_org_prefix * Cendpoint(p_migrated_erchef_from_acct) * c_maybe_identifier) * c_erchef) +
                  ((p_acct +
                   (p_named_org + p_sep)) * c_acct),

   -- Anything that routes to erchef is handled here.  In EC, this is the same
   -- as API chef routing
  internal_chef = c_erchef
}

-- caller should bypass this client version check if caller is internal lb
function routes.is_client_version_valid(version, min, max)
  local res = match(Ct(p_chef_version), version)
  if (res == nil) then
    return false
  end
  local major = tonumber(res.major)
  local minor = tonumber(res.minor)
  if (major or minor) and
     -- Look at the provided arguments, but 'special case' from before we
     -- changed our version string format. ONce we desupport that version,
     -- we will need to make a final update here.
     ((major >= min and major <= max) or (major == 0 and minor == 10)) then
    return true
  end
  return false
end

-- Return a table containing:
-- route_id (route id, nil if invalid route)
-- org_name (nil if not found)
-- endpoint (nil if not found)
-- object_name (nil if not found)
function routes.resolve_uri(mode, uri)
  route = match(Ct(uri_resolvers[mode]), uri)
  if not route then
    route = {}
  end
  return route
end

